乐开开发规范

# 编程相关：

## 乐开的包和类的命名规范

### 整体包及命名说明，先看下图

![](media/877cfe7c6414a65de75221c2597df106.png)

如图所示，com.lekei是统一的包结构，在maven依赖中对应的就是groupId标签

如下所示：

![](media/a00736b1e568af4a58f40074728feaae.png)

### 各部分具体说明

>   1.1.1配置包

>   ![](media/2bae3b1d2a189538ecfee07e502a5885.png)

>   位于com.leikai.微服务名.config包下，该包下的类通常以config或者conf结尾如上图的WebSecurityConfig，通过类名我们就可以知道这是Spring-Security的配置类

>   1.1.2枚举和常量配置包

>   ![](media/2e273de1e6d04dece7408b134ae57def.png)

>   位置与配置包同级,即com.leikai.微服务名称.enums,该包下的类通常以enum或者constant结尾。

>   1.1.3具体业务的包

>   ![](media/4ff92a9428d6b4b6e3d42a7add05081c.png)

>   具体业务的包名应做到见名知意，不能用拼音，上图中的forms的包名就表示该业务是表单查询报表，位置在com.lekai.微服务名.forms，其中包含4个包:controller（控制层）,mapper(dao,数据持久层)，service(业务服务层),各数据的bean包

>   这四个包的命名规则:

1.  控制层以Controller结尾

2.  数据持久层以Mapper结尾

3.  业务服务层以Service结尾,其中还有一个对应的实现类，在前者的命名的后面加上Impl

4.  各数据的bean包有三种情况，以应对不同的业务场景:

5.  entity对应的是数据库的表的实体，属性要与字段名对应,以Entity结尾

6.  dto是前后端交互，第三方接口,微服务接口交互的数据bean包，以DTO结尾

7.  vo是当前微服务内部使用的数据bean包，比如导出EXCEL使用的ExcelModel就以Model或者Vo结尾

>   1.1.4 存放mapper的xml文件目录

>   ![](media/5a65bb275e1d4f6656b3d539fb7d5df4.png)

>   在/resource/mapper目录下,命名规则与数据持久层一样

## 养成使用Sl4j打印日志的习惯

>   可以不用System.out.print(“….”)

>   异常处理的catch语句中也要用log.error(); 不要用e.printStrackTrace();

## 在业务的开始、结束和关键业务点位置打印日志， 

避免系统异常，而无法通过系统日志定位问题，实例如下：

日志中包含，业务功能，关键业务标识（比如，订单号orderNo），说明情况（比如，开始、完成等描述）

>   ![](media/ce72ac9aa8a268f3c4ec2cea95a9567d.png)

>   如上图所示，在一个业务的开始打印日志，表示这个业务开始执行

>   在其结束阶段也进行日志的打印，表示这个业务已经完成了。这样在业务出问题的时候能够找到是哪个业务出现了问题。

## 方法代码长度尽量不超过200行

## 使用validation框架进行参数验证

>   ![1619079641(1)](media/4767f0c15f1ab388c7cc4c51e4254680.png)

>   @NotNull和@NotBlank都是validation框架的注解，前者表示该值不能为null,但是可以为empty，后者只能作用在String类型上表示该属性trim()后长度不能为0，即不能为空格

>   trim():去除该字符串的所有空格字符

>   还有一个注解是@NotEmpty,表示不能为null,长度必须大于0，主要用于集合上

>   使用了这几个注解后，必须在调用该类时添加@Validated注解才能生效，如下图：

>   ![1619070417(1)](media/50564007f2df62efd093f0f89f86b4e3.png)

-   @Validated验证不通过时的处理方式：

    ![](media/511fc475fa3e157bc9b3741e044fcfba.png)

## 推荐使用状态模式

1.  涉及到状态相关的业务时，不推荐使用if-else结构，使用状态模式完成业务的实现

    1.1什么是状态模式

    一个对象在业务中有多个状态，每个状态的行为都不相同时，我们通常的做法是写一堆if-else条件语句，这种写法降低了代码的可读性，状态模式就是用来解决这个问题的。

    状态模式分为三个主体，State接口用来定义状态行为,Context类可以称他为环境类,所有的状态转换操作都可以由Context类来实现,最后一个就是具体状态实现类，他们都需要实现State接口并重写里面的方法。下面是一个关于放大镜正常状态，两倍状态，四倍状态的简单的示例：

**![](media/37b315239d20e704debee1b8ddf00cc4.png)**

**![](media/a08919e93dc99ff8b17b8ebcaae9a9a6.png)**

**![](media/164232845e685d120d205077f761afed.png)**

**![](media/e607db38d1865710bae2a9f4e72b22be.png)**

**![](media/45420a54d7886d6ba4462739caaccebf.png)**

>   上图的State接口中就一个简单的dispaly方法，Screen类充当的是Context环境类，三个实现State接口的就是具体的状态实现类了，下面来看看运行结果

![](media/1ac3db04ef9cb0371bf177c23796eb5d.png)

![](media/68fa5b7dda01e46b7fde9587983730d5.png)

>   可以看到我们只是简单的调用了环境类里的方法就实现了一个对象的不同状态的不同行为，这样就避免了在业务中使用大量的条件语句将状态转换和对应的行为交织在一起，从而增加了代码的可读性。

## 乐开异常处理相关:

1.  捕获异常后,为了防止该异常被吞没推荐使用如下方法打印日志，其中{}为占位符，会将","后面的参数的具体的值传进去。

    ![](media/34afaf334868eb6f32b59ac787a7b348.png)

2.  App,前端与后端交互传递信息的类不一样。LeKaiResponse\<T\>负责前后端的数据信息传递。
    MusclResponse\<T\>负责后端与app的数据信息传递\<T\>里的类型是需要获取的返回值数据类型。如果需要返回一个int类型的数据，那么\<T\>就该写为\<Integer\>,里面只能写引用类型，不能写基本类型。

## 还有其他规范可参考《阿里开发规范》文档

# sql相关:

## 数据量在需求分析阶段就要考虑

实现的功能涉及的数据量，是要在开发初期，需求分析阶段就要考虑的问题。根据数据量的情况，是要采取不同实现方案的。

## 能不写子查询就不写子查询；

## 使用SELECT关键字时不要写 \*

## SQL统计相关的聚合函数:

-   注意聚合函数走索引要考虑具体业务关联表情况，很多情况下全表扫描是必须的，此时索引无法提高效率。

    -   查看执行计划的消耗成本，进一步优化

## 索引:

1.  主键索引，建表时随表主键建立而自动建立 主键索引。

2.  唯一索引，业务不重复的值可以用此唯一索引保证唯一性。

3.  组合索引，要注意其最左原则

4.  索引方法结构：

    BTREE方法建立的索引，提高查区间的效率；

    HASH方法创建的索引，查不重复或很少重复。MySql是B+TREE；

## 索引不是越多越好

太多索引会增加维护索引的成本，编辑的表的数据量在很大的情况下，我们甚至可以删除一些索引，这样系统的整体业务性能也会得到提升；

## IN和EXISTS关键字:

IN因为是笛卡尔积的实现的原因，在IN后面的列数很多（原则上不超过5个）的情况下考虑用EXISTS
替换IN实现；

## LEFT JOIN还是 INNER JOIN：

业务为主，在业务允许情况下尽量使用INNER JOIN；

## WHERE尽量使用主键过滤,再考虑使用索引列过滤

## LIKE关键字

Like ‘%xxxx’和Like ‘%xxxx%’
一定慎用，无法走索引的，考虑ES等全文检索方案，来做文本查询实现

## GROUP BY默认是有排序消耗的；

## HAVING

根据SQL的执行顺序，HAVING是最后才执行的，查询结果数据量大时，也要少用；

## java Stream：

Java 8
API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream
使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java
集合运算和表达的高阶抽象。

换言之，我们在需要使用SQL聚合函数场景时，我们就可以将聚合函数的操作用java
Stream来操作。

以下是java Stream的一个处理流程

![](media/d5a5741c9b7bd72ca1aeeb57b619e54b.png)

将上述流程转换为java代码为:

![](media/d509ea3a9150dd6314d648cd217dc641.png)

# 持久化数据库相关: 

### 1.dynamic-datasource

主要使用的是baomidou的dynamic-datasource,使用的版本如下所示

![](media/9912218340c9f8d194ea13ec6d915fa5.png)

dynamic-datasource-spring-boot-starter是基于springboot快速集成多数据源的启动器,

其中约定了此框架只做切换数据源这个核心功能，切换数据源后可以做任何CRUD

该框架使用@DS("dsname")注解切换数据源，dsname就是想要切换的数据源的名字

该注解可以注解在方法上也可以注解在类上，同时遵循就近原则，即方法和类上同时拥有该注解，那么方法上的该注解的优先级高于类上的该注解

### 2，关于分页

强烈推荐使用物理分页；

分页过程中，如果数据量很大，总记录数的count查询操作需要特别注意，可以独立于列表查询的默认count查询，而是手动的穿件count-SQL优化，需要考虑使用日-周-月-年不同数据粒度的提前数据加工汇总方式，以避免复杂SQL导致的系统瓶颈。

# 分布式锁相关：

在遇到类似这样的业务场景时，必须加上分布式锁:假设有两个业务分别为业务A和业务B，他们同时对一个对象进行了下单，导致生成了两份相同的订单，这显然是不对的，所以这个时候我们需要一个分布式锁来将相应的进程保护起来，避免这种错误的发生。

### Redisson实现分布式锁

我们这里建议使是通过Redisson来实现分布式锁，他的实现如下:

![](media/81d8338f8506bf3bd8ed8fa9ba3b4f12.png)

在需要上锁的业务开始之前，通过调用RLock类的lock()方法将业务锁起来，最后通过try-catch-finally结构在业务完成后将锁释放就可以了。

我们这里建议是用以下方式构建分布式锁:

![](微信图片_20210602105603.png)

最后，一定要将释放锁的操作放进finally块中，这样当该进程结束时一定会释放锁，从而让一个新的进程进入。

![](media/0549dc2b6b4533ca247c4e5662eabe7a.png)

# 开发代码自测相关:

在自己写好的接口推荐先使用PostMan进行测试,下图为PostMan基本功能

![](media/642f5a1931af684326cfb387d76c14a1.png)

PostMan自身也可以进行简单的压力测试

![](media/01f5ebb7401e41a170b46631d965ac11.png)

点击自己建立的Collection，旁边有三个点，里面会出现一个下拉框，选中Run
collection就可以进行简单的压力测试了

![](media/17fec7fe8fbdeebb1c602316e1396b60.png)

RUN ORDER 表示需要测试的接口

Iterations 表示接口请求次数，输入100就表示请求该接口100次

Delay 表示间隔时间，单位时ms

# 事务相关:

### 1.修改Seata注册为Eureka

>   1.1添加依赖

>   \<dependency\>

>   \<groupId\>com.alibaba.cloud\</groupId\>

>   \<artifactId\>spring-cloud-starter-alibaba-seata\</artifactId\>

>   \<version\>2.1.3.RELEASE\</version\>

>   \<exclusions\>

>   \<exclusion\>

>   \<groupId\>io.seata\</groupId\>

>   \<artifactId\>seata-all\</artifactId\>

>   \</exclusion\>

>   \</exclusions\>

>   \</dependency\>

>   1.2修改yaml文件配置

>   ![](media/3ea8d38d5204e38a5ebd3273060073d8.png)

>   ![](media/cedfec3025e7d784000b668e9fe5e22e.png)

>   ![](media/d235f14f7893eb3aaf06caa275cb5905.png)

>   1.3事务源头写法

>   ![](media/55c9e85bacce936092a50114a2f79dc7.png)

>   1.4发起事务的微服务中，调用的其他微服务的事务分支的服务方法上加负载均衡注解@Loadbalance

>   ![](media/2add3aa1ac15214ef89b40383667e41c.png)

1.5在分支事务中，事务注解的配置传递是REQUIRES_NEW

>   ![](media/9b284e163aa72148254d42d274a8838b.png)

### 2.事务的传播机制

>   所谓事务传播机制，也就是在事务在多个方法的调用中是如何传递的，是重新创建事务还是使用父方法的事务？父方法的回滚对子方法的事务是否有影响？这些都是可以通过事务传播机制来决定的。

>   **Spring中事物的传播属性一共有七种:**

1.  **REQUIRED**:**如果有事务则加入事务，没有则新建立一个事务，是该属性的默认值**

2.  **NOT_SUPPORTED:相当于没有Spring事务，每条执行语句单独执行，单独提交**

3.  **REQUIRES_NEW：为当前方法新建立一个事务，将当前事务挂起，将新建立事务提**
    **交后再提交老事务**

4.  **MANDATORY：必须在已有事务的情况下被调用，否则会报错**

5.  **NEVER:必须在没有事务的方法中执行，否则报错**

6.  **SUPPORTS:是否使用事务取决于调用的方法是否有事务，如果有则直接用该方法的事务，没有则不用事务**

7.  **NESTED:如果当前方法存在事务，则再嵌套一个事务执行，最终提交一次。如果没有事务，则与REQUIRED类似**

### Seata事务处理原理

>   ![](media/c48cfaaa596abdfd75eb6101a1ab1876.png)

>   上图中的专业术语如下:

>   TC (Transaction Coordinator) - 事务协调者

>   维护全局和分支事务的状态，驱动全局事务提交或回滚。

>   TM (Transaction Manager) - 事务管理器

>   定义全局事务的范围：开始全局事务、提交或回滚全局事务。

>   RM (Resource Manager) - 资源管理器

>   管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

>   Business
>   是业务入口，在程序中会通过@GlobalTransaction注解来说明他是一个全局事务，在前文1.3中placeOrder类就是业务的一个入口即一个事务的发起端,这时他的角色为
>   TM（事务管理者）。

>   Business 会请求
>   TC（事务协调器，一个独立运行的服务），说明自己要开启一个全局事务，TC
>   会生成一个全局事务ID（XID），并返回给 Business。

>   TM在接收到XID后就可以调用微服务了，比如上图中的Storage服务

>   Storage 会收到 XID，知道自己的事务属于这个全局事务。Storage
>   执行自己的业务逻辑，操作本地数据库。

>   Storage 会把自己的事务注册到 TC，作为这个 XID
>   下面的一个分支事务，并且把自己的事务执行结果也告诉 TC。

>   此时 Storage 的角色是 RM（资源管理者），资源是指本地数据库。

>   Order、Account 的执行逻辑与 Storage 一致。

>   在各个微服务都执行完成后，TC 可以知道 XID
>   下各个分支事务的执行结果，TM（Business） 也就知道了。

>   Business 如果发现各个微服务的本地事务都执行成功了，就请求 TC 对这个 XID
>   提交，否则回滚。

>   TC 收到请求后，向 XID 下的所有分支事务发起相应请求。

>   各个微服务收到 TC 的请求后，执行相应指令，并把执行结果上报 TC。

##### UNDO_LOG表的作用

Seata有一个重要的机制：日志回滚

在参与了一个全局事务的所有分支事务中对应的数据库中都应该有这一张表UNDO_LOG,他会在数据库记录被修改之前，记录被修改前的值，作为之后回滚的依据。

他会收到两种请求，一是提交请求，二是回滚请求。如果是提交请求那就把UNDO_LOG中对应的记录删掉，如果是回滚请求，那么就会根据UNDO_LOG中对应的记录生成SQL语句进行回滚操作。

##### Seata的工作机制

在这里用一个官方的例子来帮助理解Seata的工作机制:

首先就是有一张product表（id，name,since）

其中一个业务的处理逻辑如下:

![](media/807645a1889b8c1fa0f28cddb05bd0b5.png)

第一阶段：

1.Seata会解析这段SQL:得到 SQL 的类型（UPDATE），表（product），条件（where name
= 'TXC'）等相关的信息。

>   2.根据条件（where name ='TXC'）生成对应的查询语句，从而定位数据。

>   ![](media/928ffb0a1b3afab7d1eca969dd834eeb.png)

>   3.查询得到的数据被称为前镜像，其结果如下:

>   ![](media/c7d4097c8a6a19f77b5b9d84c8febf25.png)

>   4.执行业务SQL,即UPDATE操作,将name更新为GTS,更新后的数据被称为后镜像

>   5.然后查询后镜像，通过前镜像得到的主键来定位结果数据,主键为id,前镜像的id为1，则查询语句为:

>   ![](media/78aa39d9079751c1bf35e209a59abcb3.png)

>   后镜像:

>   ![](media/a05a8e262d0a6aa5dc29fbea8e8c2d85.png)

6.插入回滚日志：把前后镜像数据以及业务 SQL
相关的信息组成一条回滚日志记录，插入到UNDO_LOG表中。

![](media/89c4dded42ad3b231d0c67ff13f20cc9.png)

7.提交前，向 TC 注册分支：申请 product表中，主键值等于 1 的记录的 全局锁 。

8.本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。

9.将本地事务提交的结果上报给 TC。

第二阶段——回滚:

1.  收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。

2.  通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。

3.  数据校验：拿 UNDO LOG
    中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。

4.  根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：

![](media/6f698c3253b94f6fa2b7167e40633120.png)

1.  提交本地事务。把本地事务的执行结果(即分支事务的回滚结果)提交给TC

第二阶段——提交:

1.收到 TC的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。

2.异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。

#### 高并发场景

1.在该场景下，尽量放弃全局事务管理，从业务层面去确保数据一致。

2.查询类业务多利用缓存来操作数据，从而实现高并发。如果还不满足需求，尝试拆分业务。

#### 坑点

1.seata框架要求参与事务的表名不能超过32个字符

